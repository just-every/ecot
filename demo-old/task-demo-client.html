<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Demo - Metamemory & Metacognition Visualization</title>
    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked@14.1.2/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
    <style>
        :root {
            --primary: #1a73e8;
            --primary-dark: #1557b0;
            --success: #34a853;
            --warning: #fbbc04;
            --error: #ea4335;
            --metamemory: #8e24aa;
            --metacognition: #ff6f00;
            --background: #f5f5f5;
            --surface: #ffffff;
            --text: #202124;
            --text-secondary: #959595;
            --code-bg: #f8f9fa;
            --border: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 350px 1fr 400px;
            gap: 20px;
            height: 100vh;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            min-width: 0;
            gap: 20px;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .card.small {
            padding: 16px;
        }

        h1 {
            color: var(--primary);
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 28px;
        }

        h2 {
            color: var(--text);
            margin-bottom: 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        h3 {
            color: var(--text);
            margin-bottom: 12px;
            font-size: 16px;
        }

        .metamemory-icon {
            color: var(--metamemory);
        }

        .metacognition-icon {
            color: var(--metacognition);
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text);
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
        }

        button:hover {
            background: var(--primary-dark);
        }

        button:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
        }

        .stop-button {
            background: var(--error);
            margin-top: 12px;
        }

        .stop-button:hover {
            background: #d33b2c;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-weight: 500;
        }

        .status.idle {
            background: #e8f0fe;
            color: var(--primary);
        }

        .status.running {
            background: #e8f5e8;
            color: var(--success);
        }

        .status.error {
            background: #fce8e6;
            color: var(--error);
        }

        .conversation {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            max-height: 60vh;
        }

        .message {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 16px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-row {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
            margin-top: 2px;
            font-size: 14px;
        }

        .message.user .message-avatar {
            background: var(--primary);
        }

        .message.assistant .message-avatar {
            background: var(--success);
        }

        .message.system .message-avatar {
            background: var(--text-secondary);
        }

        .message.metacognition .message-avatar {
            background: var(--metacognition);
        }

        .message-content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .message-metadata {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .thinking-content {
            background: #f0f4f8;
            border: 1px solid #d0d7de;
            border-radius: 8px;
            padding: 12px 16px;
            font-style: italic;
            color: #57606a;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .thinking-content::before {
            content: 'üí≠ Thinking: ';
            font-weight: 600;
            font-style: normal;
        }

        .message-body {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px 16px;
        }

        .message.user .message-body {
            background: #e3f2fd;
        }

        .message.assistant .message-body {
            background: #f3e5f5;
        }

        .message.system .message-body {
            background: #fff3e0;
        }

        .message.metacognition .message-body {
            background: #fce4ec;
        }

        .message-content {
            font-size: 14px;
            line-height: 1.6;
        }

        .message-content pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .message-content code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
        }
        
        /* Content div used during streaming */
        .content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Markdown content styling */
        .content h1, .content h2, .content h3,
        .content h4, .content h5, .content h6 {
            margin: 16px 0 8px 0;
            color: var(--text);
            font-weight: 600;
        }
        
        .content p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .content ul, .content ol {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .content li {
            margin: 4px 0;
        }
        
        .content pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            overflow-x: auto;
            margin: 8px 0;
        }
        
        .content code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
        }

        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .typing-indicator svg {
            opacity: 0.6;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .typing-dots {
            display: flex;
            gap: 3px;
            margin-left: 4px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: var(--text-secondary);
            border-radius: 50%;
            animation: typing 1.4s infinite;
            opacity: 0.4;
        }

        .typing-dots span:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% { 
                opacity: 0.4; 
                transform: translateY(0) scale(1); 
            }
            30% { 
                opacity: 1; 
                transform: translateY(-3px) scale(1.2); 
            }
        }

        .message-body .content {
            color: var(--text);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .tool-call {
            background: #e8f0fe;
            border: 1px solid #c2d9ff;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            font-size: 13px;
        }

        .tool-call strong {
            color: #1967d2;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
        }

        .tool-call pre {
            margin: 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .tool-result {
            background: #e6f4ea;
            border: 1px solid #ceead6;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            font-size: 13px;
        }

        .tool-result strong {
            color: #188038;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
        }

        .tool-result pre {
            margin: 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }


        .tool-result.task-complete {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .tool-result.task-error {
            background: #ffebee;
            border-color: #f44336;
        }

        .thread-indicator {
            background: #f3e5f5;
            border-left: 4px solid var(--metamemory);
            font-size: 12px;
            padding: 12px;
            margin: 10px 0;
        }

        .thread-badge {
            display: inline-block;
            background: var(--metamemory);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }

        .compaction-indicator {
            background: #e8f5e9;
            border: 2px dashed var(--success);
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            text-align: center;
        }

        .compaction-indicator h4 {
            color: var(--success);
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .compaction-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 12px;
        }

        .compaction-stat {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .compaction-stat strong {
            color: var(--success);
            font-size: 16px;
        }

        .metamemory-panel {
            max-height: 300px;
            overflow-y: auto;
        }

        .thread {
            background: #f8f9fa;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .thread-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .thread-name {
            font-weight: 600;
            color: var(--metamemory);
        }

        .thread-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .thread-status.active {
            background: #e8f5e8;
            color: var(--success);
        }

        .thread-status.complete {
            background: #e3f2fd;
            color: var(--primary);
        }

        .thread-status.paused {
            background: #fce8e6;
            color: var(--error);
        }

        .thread-messages {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .llm-requests-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .llm-request {
            background: #f8f9fa;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .llm-request:hover {
            background: #f0f0f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .llm-request.metamemory {
            border-left: 4px solid var(--metamemory);
        }

        .llm-request.metacognition {
            border-left: 4px solid var(--metacognition);
        }

        .llm-request.main {
            border-left: 4px solid var(--primary);
        }

        .llm-request.tool {
            border-left: 4px solid #6c757d;
        }

        .llm-request.other {
            border-left: 4px solid #868e96;
        }

        .request-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .request-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            margin-right: 8px;
        }

        .request-tag.main {
            background: #e3f2fd;
            color: #1565c0;
        }

        .request-tag.metamemory {
            background: #f3e5f5;
            color: #6a1b9a;
        }

        .request-tag.metacognition {
            background: #fff3e0;
            color: #e65100;
        }

        .request-tag.tool {
            background: #e9ecef;
            color: #495057;
        }

        .request-tag.other {
            background: #f8f9fa;
            color: #6c757d;
        }

        .agent-name {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .request-details {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .request-content {
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .request-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .request-status.pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .request-status.complete {
            background: #d4edda;
            color: #155724;
        }
        
        .request-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .metric {
            text-align: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .metric-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .config-section {
            margin-bottom: 20px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .config-section .form-group:last-child {
            margin-bottom: 0;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle input[type="checkbox"] {
            width: auto;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }
        
        /* Example task buttons */
        .example-tasks {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .example-task-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .example-task-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .example-task-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
        
        /* Advanced Settings */
        .advanced-section {
            margin: 10px 0;
            padding: 16px 0;
            border-top: 1px solid var(--border);
        }
        
        .advanced-toggle {
            width: 100%;
            background: none;
            border: none;
            padding: 8px 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
            transition: color 0.2s;
        }
        
        .advanced-toggle:hover {
            color: var(--text);
        }
        
        .advanced-toggle .chevron {
            transition: transform 0.2s;
        }
        
        .advanced-toggle.expanded .chevron {
            transform: rotate(180deg);
        }
        
        .advanced-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            margin-top: 12px;
        }
        
        .advanced-content.expanded {
            max-height: 600px;
        }
        
        /* Modal styles for LLM request details */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background: var(--surface);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 4px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            background: #f0f0f0;
            color: var(--text);
        }
        
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .request-detail-section {
            margin-bottom: 24px;
        }
        
        .request-detail-section h4 {
            color: var(--text);
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .request-detail-content {
            background: #f8f9fa;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .request-metadata {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .metadata-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
        }
        
        .metadata-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .metadata-value {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 300px 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .right-panel {
                grid-column: 1 / -1;
                grid-row: 2;
            }
        }

        /* Thread Details Modal */
        .thread-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }

        .thread-details-modal {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .thread-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .thread-details-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .thread-status-badge {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .thread-status-badge.active {
            background: #dcfce7;
            color: #166534;
        }

        .thread-status-badge.complete {
            background: #dbeafe;
            color: #1e40af;
        }

        .thread-status-badge.paused {
            background: #fef3c7;
            color: #92400e;
        }

        .thread-details-info {
            margin-bottom: 24px;
        }

        .thread-info-row {
            margin-bottom: 12px;
            font-size: 14px;
        }

        .thread-info-row strong {
            color: var(--text-primary);
            margin-right: 8px;
        }

        .thread-summary {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 13px;
            line-height: 1.5;
        }

        .thread-key-points {
            margin: 8px 0 0 20px;
            font-size: 13px;
        }

        .thread-key-points li {
            margin-bottom: 4px;
        }

        .thread-messages-section h4 {
            margin: 0 0 16px 0;
            color: var(--text-primary);
            font-size: 16px;
        }

        .thread-messages-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
        }

        .thread-message-item {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            font-size: 13px;
            border: 1px solid #e0e0e0;
        }

        .message-number {
            background: var(--primary);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
            margin-right: 12px;
            min-width: 28px;
            text-align: center;
            font-size: 11px;
        }

        .message-role-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            margin-right: 12px;
            min-width: 50px;
            text-align: center;
        }

        .message-role-badge.user {
            background: #e3f2fd;
            color: #1565c0;
        }

        .message-role-badge.assistant {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .message-role-badge.system {
            background: #fff3e0;
            color: #ef6c00;
        }

        .message-content-preview {
            flex: 1;
            min-width: 0;
        }

        .message-preview-text {
            line-height: 1.4;
            margin-bottom: 4px;
            color: var(--text);
        }

        .message-id-small {
            font-family: 'Monaco', 'Consolas', monospace;
            color: var(--text-secondary);
            font-size: 10px;
        }

        .message-id {
            font-family: 'Monaco', 'Consolas', monospace;
            color: var(--text-secondary);
            flex: 1;
            margin-right: 12px;
        }

        .message-meta {
            color: var(--text-secondary);
            font-style: italic;
        }

        .no-messages {
            text-align: center;
            color: var(--text-secondary);
            padding: 20px;
            font-style: italic;
        }

        .thread-details-actions {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            text-align: right;
        }

        .close-button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .close-button:hover {
            background: #2563eb;
        }

        /* Make threads appear clickable */
        .thread.clickable:hover {
            background: #f0f4ff;
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }

        .importance-bar {
            width: 100%;
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            margin-top: 4px;
            overflow: hidden;
        }

        .importance-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd93d, #6bcf7f);
            transition: width 0.3s ease;
        }

        .thread-analysis-section {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9ff;
            border-radius: 8px;
            border: 1px solid #e0e7ff;
        }

        .thread-analysis-section h4 {
            margin: 0 0 12px 0;
            color: var(--primary);
        }

        .analysis-item {
            margin-bottom: 8px;
            font-size: 13px;
        }

        .analysis-content {
            font-size: 13px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar: Configuration -->
        <div class="sidebar">
            <div class="card">
                <h2>üß† Task Configuration</h2>
                
                <div class="config-section">
                    <h3>Basic Settings</h3>
                    <div class="form-group">
                        <label for="agentName">Agent Name</label>
                        <input type="text" id="agentName" value="TaskDemoAgent" />
                    </div>
                    <div class="form-group">
                        <label for="modelClass">Model Class</label>
                        <select id="modelClass">
                            <option value="reasoning">Reasoning</option>
                            <option value="standard">Standard</option>
                            <option value="mini" selected>Mini</option>
                            <option value="summary">Summary</option>
                        </select>
                    </div>
                </div>

                <div class="advanced-section">
                    <button type="button" class="advanced-toggle" onclick="window.toggleAdvanced()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="chevron">
                            <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                        </svg>
                        Advanced Settings
                    </button>
                    <div class="advanced-content" id="advancedContent">
                        <div class="config-section">
                            <h3>Metamemory Settings</h3>
                            <div class="toggle">
                                <input type="checkbox" id="metamemoryEnabled" checked />
                                <label for="metamemoryEnabled">Enable Metamemory</label>
                            </div>
                            <div class="form-group">
                                <label for="processInterval">Process Interval</label>
                                <input type="number" id="processInterval" value="2" min="1" max="10" />
                            </div>
                            <div class="form-group">
                                <label for="windowSize">Window Size</label>
                                <input type="number" id="windowSize" value="10" min="5" max="50" />
                            </div>
                        </div>

                        <div class="config-section">
                            <h3>Metacognition Settings</h3>
                            <div class="form-group">
                                <label for="metaFrequency">Meta Frequency</label>
                                <select id="metaFrequency">
                                    <option value="5">Every 5 requests</option>
                                    <option value="10" selected>Every 10 requests</option>
                                    <option value="20">Every 20 requests</option>
                                    <option value="40">Every 40 requests</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="thoughtDelay">Thought Delay (s)</label>
                                <input type="number" id="thoughtDelay" value="0" min="0" max="10" />
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Status</h3>
                <div id="status" class="status idle">Ready to start</div>
                
                <div class="form-group">
                    <label for="taskDescription">Task Description</label>
                    <textarea id="taskDescription" placeholder="Enter your task here... (e.g., 'Explain recursion, then closures, then REST APIs')">Help me understand three programming concepts: recursion, closures in JavaScript, and REST APIs. Explain each one clearly with examples.</textarea>
                </div>
                
                <button id="startButton">Start Task</button>
                <button id="stopButton" class="stop-button hidden">Stop Task</button>
            </div>

            <div class="card">
                <h3>Example Tasks</h3>
                <div class="example-tasks">
                    <button class="example-task-btn" onclick="window.setExampleTask('research')">
                        üîç Research & Summarize
                    </button>
                    <button class="example-task-btn" onclick="window.setExampleTask('travel')">
                        ‚úàÔ∏è Plan a Trip
                    </button>
                    <button class="example-task-btn" onclick="window.setExampleTask('code')">
                        üíª Analyze Code
                    </button>
                    <button class="example-task-btn" onclick="window.setExampleTask('data')">
                        üìä Data Analysis
                    </button>
                    <button class="example-task-btn" onclick="window.setExampleTask('creative')">
                        ‚úçÔ∏è Creative Writing
                    </button>
                    <button class="example-task-btn" onclick="window.setExampleTask('debug')">
                        üêõ Debug Issue
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content: Conversation -->
        <div class="main-content">
            <div class="card">
                <h1>üí¨ Task Conversation</h1>
                <div id="conversation" class="conversation">
                    <div class="message system">
                        <div class="message-header">
                            <span>System</span>
                            <span>Ready</span>
                        </div>
                        <div class="message-content">Task demo ready. Configure settings and click "Start Task" to begin.</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìä Metrics</h2>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="messageCount">0</div>
                        <div class="metric-label">Messages</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="requestCount">0</div>
                        <div class="metric-label">LLM Requests</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="metamemoryAnalysis">0</div>
                        <div class="metric-label">Message Analysis</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="threadSummaries">0</div>
                        <div class="metric-label">Thread Summaries</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Metamemory & LLM Requests -->
        <div class="right-panel">
            <div class="card small">
                <h2><span class="metamemory-icon">üßµ</span> Metamemory Threads</h2>
                <div id="metamemoryThreads" class="metamemory-panel">
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No threads yet. Start a task to see metamemory in action.
                    </div>
                </div>
            </div>

            <div class="card small">
                <h2><span class="metacognition-icon">üî¨</span> LLM Requests</h2>
                <div id="llmRequests" class="llm-requests-panel">
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No requests yet. LLM calls will appear here.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for LLM Request Details -->
    <div id="requestModal" class="modal-overlay" onclick="if(event.target === this) hideRequestModal()">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">LLM Request Details</h3>
                <button class="modal-close" onclick="hideRequestModal()">√ó</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Request details will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        class TaskDemo {
            constructor() {
                this.ws = null;
                this.isRunning = false;
                this.isStreaming = false;
                this.currentMessageElement = null;
                this.currentMessageModel = null;
                this.currentMessageClass = null;
                this.metrics = {
                    messageCount: 0,
                    requestCount: 0,
                    metamemoryAnalysis: 0,
                    threadSummaries: 0
                };
                this.metamemoryState = null;
                this.llmRequests = [];
                this.llmRequestDetails = new Map();

                this.initializeEventListeners();
                this.connectWebSocket();
            }

            initializeEventListeners() {
                document.getElementById('startButton').addEventListener('click', () => this.startTask());
                document.getElementById('stopButton').addEventListener('click', () => this.stopTask());
            }

            connectWebSocket() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to Task demo server');
                        this.updateStatus('Connected to server', 'idle');
                    };

                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleServerMessage(data);
                    };

                    this.ws.onclose = () => {
                        console.log('Disconnected from server');
                        this.updateStatus('Disconnected from server', 'error');
                        
                        // Attempt to reconnect after 3 seconds
                        setTimeout(() => this.connectWebSocket(), 3000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('Connection error', 'error');
                    };
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.updateStatus('Failed to connect to server', 'error');
                }
            }

            handleServerMessage(data) {
                        console.log('handleServerMessage', data);
                switch (data.type) {
                    case 'agent_start':
                        this.handleAgentStart(data);
                        break;
                    case 'stream_start':
                        this.handleStreamStart(data);
                        break;
                    case 'message_start':
                        this.handleMessageStart(data);
                        break;
                    case 'message_delta':
                        this.handleMessageDelta(data);
                        break;
                    case 'message_complete':
                        this.handleMessageComplete(data);
                        break;
                    case 'stream_end':
                        this.handleStreamEnd(data);
                        break;
                    case 'tool_call':
                        // Skip tool_call events, we'll use tool_start instead
                        break;
                    case 'tool_start':
                        this.handleToolCall(data);
                        break;
                    case 'tool_result':
                        // Skip tool_result events, we'll use tool_done instead
                        break;
                    case 'tool_done':
                        this.handleToolResult(data);
                        break;
                    case 'content':
                        this.handleContentEvent(data);
                        break;
                    case 'response_output':
                        this.handleResponseOutput(data);
                        break;
                    case 'task_complete':
                        this.handleTaskComplete(data);
                        break;
                    case 'task_fatal_error':
                        this.handleTaskError(data);
                        break;
                    case 'metamemory_update':
                        this.handleMetamemoryUpdate(data);
                        break;
                    case 'metacognition_trigger':
                        this.handleMetacognitionTrigger(data);
                        break;
                    case 'metamemory_final_state':
                        this.handleMetamemoryFinalState(data);
                        break;
                    case 'metamemory_live_update':
                        this.handleMetamemoryLiveUpdate(data);
                        break;
                    case 'llm_request':
                        this.handleLLMRequest(data);
                        break;
                    case 'llm_request_detailed':
                        this.handleDetailedLLMRequest(data);
                        break;
                    case 'llm_response_detailed':
                        this.handleDetailedLLMResponse(data);
                        break;
                    case 'llm_error_detailed':
                        this.handleDetailedLLMError(data);
                        break;
                    case 'llm_request_details':
                        this.showRequestDetails(data.data);
                        break;
                    case 'error':
                        this.handleError(data);
                        break;
                    default:
                        console.log('Unknown message type:', data.type, data);
                }
            }

            handleContentEvent(data) {
                // This is a legacy event, we'll handle it but prefer message_delta
                if (this.currentMessageElement && data.content) {
                    this.appendToCurrentMessage(data.content);
                }
            }

            handleAgentStart(data) {
                // Only create a typing indicator for main conversation agents
                // Skip metamemory, metacognition, and other background agents
                if (data.agent) {
                    const agentName = data.agent.name || '';
                    console.log('Agent start:', agentName, data.agent);
                    
                    // Check if this is a background agent we should skip
                    const isBackgroundAgent = 
                        agentName.toLowerCase().includes('metamemory') ||
                        agentName.toLowerCase().includes('metacognition') ||
                        agentName.toLowerCase().includes('analysis') ||
                        agentName.toLowerCase().includes('summarizer') ||
                        agentName.toLowerCase().includes('mock');
                    
                    if (!isBackgroundAgent) {
                        // Main conversation agent - show typing indicator
                        this.currentMessageModel = data.agent.model;
                        this.currentMessageClass = data.agent.modelClass;
                        this.currentMessageElement = this.addStreamingMessage('assistant');
                    } else {
                        // Background agent - don't show typing indicator
                        console.log('Skipping typing indicator for background agent:', agentName);
                        this.currentMessageElement = null;
                    }
                }
            }

            handleStreamStart(data) {
                this.isStreaming = true;
                // Update model if server provides it
                if (data.model) {
                    this.currentMessageModel = data.model;
                }
                this.updateButtons();
            }

            handleMessageStart(data) {
                // Message element already created in agent_start
                if (data.model) {
                    this.currentMessageModel = data.model;
                }
            }

            handleMessageDelta(data) {
                if (this.currentMessageElement && data.content) {
                    // Remove typing indicator if present - it's a direct child of message-body
                    const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        console.log('Removing typing indicator from message delta');
                        typingIndicator.remove();
                    }

                    // Get or create content div
                    let contentDiv = this.currentMessageElement.querySelector('.content');
                    if (!contentDiv) {
                        contentDiv = document.createElement('div');
                        contentDiv.className = 'content';
                        this.currentMessageElement.appendChild(contentDiv);
                    }

                    // Append the delta content (incremental) - keep as plain text during streaming
                    contentDiv.textContent += data.content;
                    
                    // Scroll to bottom
                    const conversation = document.getElementById('conversation');
                    conversation.scrollTop = conversation.scrollHeight;
                }
                
                // Handle thinking content separately if present
                if (data.thinking_content) {
                    this.appendThinkingContent(data.thinking_content);
                }
            }

            handleMessageComplete(data) {
                if (this.currentMessageElement && data.content) {
                    // Ensure typing indicator is removed - it's a direct child of message-body
                    const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        console.log('Removing typing indicator from message complete');
                        typingIndicator.remove();
                    }

                    // Get or create content div
                    let contentDiv = this.currentMessageElement.querySelector('.content');
                    if (!contentDiv) {
                        contentDiv = document.createElement('div');
                        contentDiv.className = 'content';
                        this.currentMessageElement.appendChild(contentDiv);
                    }

                    // Render the final content as markdown
                    const html = marked.parse(data.content);
                    const sanitizedHtml = DOMPurify.sanitize(html);
                    contentDiv.innerHTML = sanitizedHtml;
                }
                
                // Handle thinking content if present and not already added
                if (data.thinking_content) {
                    let thinkingDiv = this.currentMessageElement.querySelector('.thinking-content');
                    if (!thinkingDiv) {
                        thinkingDiv = document.createElement('div');
                        thinkingDiv.className = 'thinking-content';
                        this.currentMessageElement.insertBefore(thinkingDiv, this.currentMessageElement.firstChild);
                    }
                    thinkingDiv.textContent = data.thinking_content;
                }
                
                // Update token counts if provided
                if (data.usage) {
                    this.metrics.requestCount++;
                    this.updateMetrics();
                }
            }

            handleStreamEnd(data) {
                this.isStreaming = false;
                // Ensure any remaining typing indicators are removed
                if (this.currentMessageElement) {
                    const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        console.log('Removing typing indicator in stream end');
                        typingIndicator.remove();
                    }
                }
                this.currentMessageElement = null;
                this.currentMessageModel = null;
                this.currentMessageClass = null;
                this.updateButtons();
            }

            handleToolCall(data) {
                // Get the last assistant message body if we don't have a current element
                let targetElement = this.currentMessageElement;
                if (!targetElement) {
                    const conversation = document.getElementById('conversation');
                    const messages = conversation.querySelectorAll('.message.assistant');
                    const lastMessage = messages[messages.length - 1];
                    if (lastMessage) {
                        targetElement = lastMessage.querySelector('.message-body');
                    }
                }

                // Handle both tool_call and tool_start events
                if (targetElement && data.tool_call) {
                    const toolDiv = document.createElement('div');
                    toolDiv.className = 'tool-call';

                    // Format arguments nicely
                    let formattedArgs = '';
                    try {
                        const args = typeof data.tool_call.function.arguments === 'string'
                            ? JSON.parse(data.tool_call.function.arguments)
                            : data.tool_call.function.arguments;
                        formattedArgs = JSON.stringify(args, null, 2);
                    } catch {
                        formattedArgs = data.tool_call.function.arguments || '{}';
                    }

                    toolDiv.innerHTML = `<strong>üîß Calling ${data.tool_call.function.name}:</strong><br><pre>${formattedArgs}</pre>`;
                    targetElement.appendChild(toolDiv);
                } else if (targetElement && data.tool && data.arguments) {
                    // Fallback for simple tool events
                    const toolDiv = document.createElement('div');
                    toolDiv.className = 'tool-call';
                    toolDiv.innerHTML = `<strong>üîß Calling ${data.tool}:</strong><br><pre>${JSON.stringify(data.arguments, null, 2)}</pre>`;
                    targetElement.appendChild(toolDiv);
                }
            }

            handleToolResult(data) {
                // Get the last assistant message body if we don't have a current element
                let targetElement = this.currentMessageElement;
                if (!targetElement) {
                    const conversation = document.getElementById('conversation');
                    const messages = conversation.querySelectorAll('.message.assistant');
                    const lastMessage = messages[messages.length - 1];
                    if (lastMessage) {
                        targetElement = lastMessage.querySelector('.message-body');
                    }
                }

                // Handle both tool_result and tool_done events
                if (targetElement && data.result) {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'tool-result';

                    // Format result nicely
                    let formattedResult = data.result.output || data.result.error || data.result || 'No result';

                    // Handle task_complete and task_fatal_error specially
                    const toolName = data.tool_call?.function?.name || data.tool;
                    if (toolName === 'task_complete') {
                        resultDiv.className = 'tool-result task-complete';
                        resultDiv.innerHTML = `<strong>‚úÖ Task Completed:</strong><br><pre style="white-space: pre-wrap;">${formattedResult}</pre>`;
                    } else if (toolName === 'task_fatal_error') {
                        resultDiv.className = 'tool-result task-error';
                        resultDiv.innerHTML = `<strong>‚ùå Task Failed:</strong><br><pre style="white-space: pre-wrap;">${formattedResult}</pre>`;
                    } else {
                        // Try to parse and format JSON-like results
                        try {
                            if (typeof formattedResult === 'string' && formattedResult.includes('{') && formattedResult.includes('}')) {
                                // Extract JSON part and format it
                                const jsonMatch = formattedResult.match(/\{[^}]+\}/);
                                if (jsonMatch) {
                                    const jsonPart = JSON.parse(jsonMatch[0]);
                                    const nonJsonPart = formattedResult.replace(jsonMatch[0], '').trim();
                                    const formattedJson = JSON.stringify(jsonPart, null, 2);
                                    formattedResult = nonJsonPart ? `${formattedJson}\n\n${nonJsonPart}` : formattedJson;
                                }
                            }
                        } catch {
                            // Keep original format if parsing fails
                        }
                        resultDiv.innerHTML = `<strong>‚úÖ Result:</strong><br><pre style="white-space: pre-wrap;">${formattedResult}</pre>`;
                    }
                    
                    targetElement.appendChild(resultDiv);
                }
            }

            handleResponseOutput(data) {
                // Only count messages if we have a current element (not background agents)
                if (this.currentMessageElement) {
                    this.metrics.messageCount++;
                    this.updateMetrics();
                }
                
                if (data.message && this.currentMessageElement) {
                    // We already have a streaming message, just finalize it
                    const contentDiv = this.currentMessageElement.querySelector('.message-content');
                    if (contentDiv) {
                        contentDiv.innerHTML = marked.parse(DOMPurify.sanitize(data.message.content));
                    }
                } else if (data.message) {
                    // No streaming message exists, create a complete one
                    this.addMessage('assistant', data.message.content, 'Complete');
                }
            }

            handleTaskComplete(data) {
                this.isRunning = false;
                this.updateStatus('Task completed successfully', 'idle');
                this.updateButtons();
                
                // Don't add a system message here - the tool_done event already shows the completion
                
                // Show compaction visualization only - metamemory display is handled by handleMetamemoryFinalState
                if (data.finalState) {
                    setTimeout(() => {
                        this.showCompactionVisualization(data.finalState);
                    }, 1000);
                }
            }

            handleTaskError(data) {
                this.isRunning = false;
                this.updateStatus('Task failed', 'error');
                this.updateButtons();
                
                // Don't add a system message here - the tool_done event already shows the error
            }

            handleMetamemoryUpdate(data) {
                // Track the state updates
                if (data.state) {
                    this.metamemoryState = data.state;
                    this.updateMetamemoryDisplay(data.state);
                }
                
                // Show thread assignment indicators in conversation
                if (data.trigger && data.trigger.type === 'thread_assignments' && data.details) {
                    this.addThreadIndicator(data.details);
                }
                
                // Only show meaningful metamemory events
                if (data.trigger && data.trigger.type === 'processing_complete') {
                    this.addMessage('system', `Metamemory processing completed`, 'Metamemory');
                }
            }

            handleMetacognitionTrigger(data) {
                // Metacognition is shown as a message but not tracked as a separate metric
                this.addMessage('metacognition', data.content || 'Metacognition triggered', 'Meta-thought');
            }

            handleMetamemoryFinalState(data) {
                console.log('Received metamemory final state:', data);
                console.log('State threads object:', data.state?.threads);
                console.log('Number of threads:', data.state?.threads ? Object.keys(data.state.threads).length : 0);
                if (data.state) {
                    this.metamemoryState = data.state;
                    this.updateMetamemoryDisplay(data.state);
                }
            }

            handleMetamemoryLiveUpdate(data) {
                console.log('Received live metamemory update:', data);
                console.log('Live state threads:', data.state?.threads);
                console.log('Number of live threads:', data.state?.threads ? Object.keys(data.state.threads).length : 0);
                if (data.state) {
                    this.metamemoryState = data.state;
                    this.updateMetamemoryDisplay(data.state);
                }
            }

            handleLLMRequest(data) {
                // Skip this - we use handleDetailedLLMRequest instead
            }

            handleError(data) {
                console.error('Server error:', data.error);
                this.updateStatus(`Error: ${data.error}`, 'error');
            }

            handleDetailedLLMRequest(data) {
                this.metrics.requestCount++;
                
                // Track metamemory-specific requests - exact match on agent names
                const agentName = data.agentId || '';
                console.log('LLM Request from agent:', agentName);
                
                if (agentName === 'MetamemoryAnalyzer' || 
                    agentName.toLowerCase().includes('metamemoryanalyzer')) {
                    this.metrics.metamemoryAnalysis++;
                    console.log('Incrementing message analysis counter');
                } else if (agentName === 'ThreadSummarizer' || 
                           agentName.toLowerCase().includes('threadsummarizer')) {
                    this.metrics.threadSummaries++;
                    console.log('Incrementing thread summaries counter');
                }
                
                this.updateMetrics();
                
                // Store request details
                this.llmRequestDetails.set(data.requestId, {
                    id: data.requestId,
                    agentId: data.agentId,
                    provider: data.provider,
                    model: data.model,
                    timestamp: data.timestamp,
                    request: data.request,
                    status: data.status
                });
                
                // Add to UI
                this.addDetailedLLMRequest(data);
            }

            addDetailedLLMRequest(data) {
                const container = document.getElementById('llmRequests');
                
                // Clear placeholder if this is the first request
                if (container.querySelector('div[style*="text-align: center"]')) {
                    container.innerHTML = '';
                }
                
                const requestDiv = document.createElement('div');
                requestDiv.className = 'llm-request';
                requestDiv.id = `request-${data.requestId}`;
                requestDiv.dataset.requestId = data.requestId;
                
                // Determine request type and tag based on agent name
                let requestType = 'main';
                let requestTag = 'Conversation';
                
                const agentName = data.agentId || '';
                if (agentName === 'MetamemoryAnalyzer') {
                    requestType = 'metamemory';
                    requestTag = 'Message Analysis';
                } else if (agentName === 'ThreadSummarizer') {
                    requestType = 'metamemory';
                    requestTag = 'Thread Summary';
                } else if (agentName.toLowerCase().includes('metacognition') || 
                          agentName.toLowerCase().includes('meta-thought')) {
                    requestType = 'metacognition';
                    requestTag = 'Metacognition';
                } else if (agentName.toLowerCase().includes('mockresponsegenerator')) {
                    requestType = 'tool';
                    requestTag = 'Tool Mock';
                } else if (agentName && agentName !== 'TaskDemoAgent') {
                    // Other non-main agents
                    requestType = 'other';
                    requestTag = 'Other';
                }
                
                requestDiv.classList.add(requestType);
                
                // Truncate the request for preview
                const requestPreview = this.truncateRequestForPreview(data.request);
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                
                requestDiv.innerHTML = `
                    <div class="request-header">
                        <div>
                            <span class="request-tag ${requestType}">${requestTag}</span>
                            <span class="agent-name">${data.agentId}</span>
                        </div>
                        <div class="request-status ${data.status}">${data.status}</div>
                    </div>
                    <div class="request-details">
                        ${data.provider} ‚Ä¢ ${data.model} ‚Ä¢ ${timestamp}
                    </div>
                    <div class="request-content">
                        ${requestPreview}
                    </div>
                `;
                
                // Make request clickable to view details
                requestDiv.addEventListener('click', () => {
                    this.showRequestDetails(this.llmRequestDetails.get(data.requestId));
                });
                
                // Add to top of container
                container.insertBefore(requestDiv, container.firstChild);
                
                // Keep only last 20 requests visible
                while (container.children.length > 20) {
                    container.removeChild(container.lastChild);
                }
            }

            truncateRequestForPreview(request) {
                if (!request) return 'No request data';
                
                // Handle different request formats
                let preview = '';
                if (typeof request === 'string') {
                    preview = request;
                } else if (Array.isArray(request)) {
                    // For message arrays, show the last user message
                    const lastUserMsg = request.filter(m => m.role === 'user').pop();
                    preview = lastUserMsg ? lastUserMsg.content : JSON.stringify(request);
                } else if (typeof request === 'object') {
                    preview = JSON.stringify(request);
                }
                
                // Truncate to 150 characters
                if (preview.length > 150) {
                    preview = preview.substring(0, 150) + '...';
                }
                
                return preview;
            }

            handleDetailedLLMResponse(data) {
                const request = this.llmRequestDetails.get(data.requestId);
                if (request) {
                    request.response = data.response;
                    request.status = data.status;
                    request.duration = data.duration;
                    
                    // Update UI
                    this.updateLLMRequestStatus(data.requestId, 'complete', data.duration);
                }
            }

            handleDetailedLLMError(data) {
                const request = this.llmRequestDetails.get(data.requestId);
                if (request) {
                    request.error = data.error;
                    request.status = data.status;
                    request.duration = data.duration;
                    
                    // Update UI
                    this.updateLLMRequestStatus(data.requestId, 'error', data.duration);
                }
            }

            startTask() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.updateStatus('Not connected to server', 'error');
                    return;
                }

                const config = {
                    agentName: document.getElementById('agentName').value,
                    modelClass: document.getElementById('modelClass').value,
                    taskDescription: document.getElementById('taskDescription').value,
                    metamemoryEnabled: document.getElementById('metamemoryEnabled').checked,
                    metamemoryOptions: {
                        processInterval: parseInt(document.getElementById('processInterval').value),
                        windowSize: parseInt(document.getElementById('windowSize').value)
                    },
                    metaFrequency: document.getElementById('metaFrequency').value,
                    thoughtDelay: document.getElementById('thoughtDelay').value
                };

                this.isRunning = true;
                this.updateStatus('Starting task...', 'running');
                this.updateButtons();
                this.resetMetrics();
                this.clearDisplay();

                this.ws.send(JSON.stringify({
                    type: 'start_task',
                    config: config
                }));

                this.addMessage('user', config.taskDescription, 'Sent');
            }

            stopTask() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type: 'stop_task' }));
                }
                
                this.isRunning = false;
                this.updateStatus('Task stopped', 'idle');
                this.updateButtons();
            }

            addMessage(role, content, status = '') {
                const conversation = document.getElementById('conversation');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const avatarContent = this.getAvatarContent(role);
                const timestamp = new Date().toLocaleTimeString();
                
                let metadataText = '';
                if (this.currentMessageModel && this.currentMessageClass) {
                    metadataText = `Class: ${this.currentMessageClass} ‚Ä¢ Model: ${this.currentMessageModel} ‚Ä¢ ${timestamp}`;
                } else {
                    metadataText = timestamp;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-row">
                        <div class="message-avatar">${avatarContent}</div>
                        <div class="message-content-wrapper">
                            <div class="message-metadata">${metadataText}</div>
                            <div class="message-body">
                                <div class="message-content">${marked.parse(DOMPurify.sanitize(content))}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                conversation.appendChild(messageDiv);
                conversation.scrollTop = conversation.scrollHeight;
                return messageDiv;
            }

            addStreamingMessage(role) {
                const conversation = document.getElementById('conversation');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const avatarContent = this.getAvatarContent(role);
                const timestamp = new Date().toLocaleTimeString();
                
                let metadataText = '';
                if (this.currentMessageModel && this.currentMessageClass) {
                    metadataText = `Class: ${this.currentMessageClass} ‚Ä¢ Model: ${this.currentMessageModel} ‚Ä¢ ${timestamp}`;
                } else if (this.currentMessageClass) {
                    metadataText = `Class: ${this.currentMessageClass} ‚Ä¢ ${timestamp}`;
                } else {
                    metadataText = timestamp;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-row">
                        <div class="message-avatar">${avatarContent}</div>
                        <div class="message-content-wrapper">
                            <div class="message-metadata">${metadataText}</div>
                            <div class="message-body">
                                <div class="typing-indicator">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
                                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                                    </svg>
                                    <span>Processing</span>
                                    <div class="typing-dots">
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                conversation.appendChild(messageDiv);
                conversation.scrollTop = conversation.scrollHeight;
                
                // Return the message body element for content appending
                return messageDiv.querySelector('.message-body');
            }

            appendThinkingContent(content) {
                if (!this.currentMessageElement) return;
                
                // Check if thinking content div already exists
                let thinkingDiv = this.currentMessageElement.querySelector('.thinking-content');
                if (!thinkingDiv) {
                    thinkingDiv = document.createElement('div');
                    thinkingDiv.className = 'thinking-content';
                    // Insert at the beginning of message body
                    this.currentMessageElement.insertBefore(thinkingDiv, this.currentMessageElement.firstChild);
                }
                
                // Append content (without the prefix since CSS adds it)
                thinkingDiv.textContent = (thinkingDiv.textContent || '').replace(/^üí≠ Thinking: /, '') + content;
            }

            appendToCurrentMessage(content) {
                if (!this.currentMessageElement) return;
                
                // This method is now deprecated - handleMessageDelta handles content directly
                console.warn('appendToCurrentMessage is deprecated, use handleMessageDelta instead');
            }

            getAvatarContent(role) {
                switch (role) {
                    case 'user': return 'U';
                    case 'assistant': return 'A';
                    case 'system': return 'S';
                    case 'metacognition': return 'M';
                    default: return role.charAt(0).toUpperCase();
                }
            }


            addDetailedLLMRequest(data) {
                const container = document.getElementById('llmRequests');
                
                // Clear placeholder if this is the first request
                if (this.llmRequestDetails.size === 1) {
                    container.innerHTML = '';
                }
                
                const requestDiv = document.createElement('div');
                requestDiv.className = `llm-request ${this.getRequestSource(data)}`;
                requestDiv.id = `request-${data.requestId}`;
                requestDiv.onclick = () => this.viewRequestDetails(data.requestId);
                
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                
                requestDiv.innerHTML = `
                    <div class="request-header">
                        <span>${data.provider} - ${data.model}</span>
                        <span class="request-status pending">Pending...</span>
                    </div>
                    <div class="request-details">
                        ${timestamp} ‚Ä¢ Click to view details
                    </div>
                `;
                
                container.insertBefore(requestDiv, container.firstChild);
                
                // Keep only last 50 requests
                while (container.children.length > 50) {
                    container.removeChild(container.lastChild);
                }
            }

            updateLLMRequestStatus(requestId, status, duration) {
                const requestDiv = document.getElementById(`request-${requestId}`);
                if (requestDiv) {
                    const statusSpan = requestDiv.querySelector('.request-status');
                    if (statusSpan) {
                        statusSpan.className = `request-status ${status}`;
                        statusSpan.textContent = status === 'complete' ? 
                            `Complete (${(duration / 1000).toFixed(2)}s)` : 
                            status === 'error' ? 'Error' : 'Pending...';
                    }
                }
            }

            getRequestSource(data) {
                // Determine source based on agent ID or model
                if (data.agentId) {
                    const agentIdLower = data.agentId.toLowerCase();
                    if (agentIdLower.includes('metacognition') || agentIdLower.includes('meta-cognition')) return 'metacognition';
                    if (agentIdLower.includes('metamemory') || agentIdLower.includes('memory')) return 'metamemory';
                }
                // Also check model name for summary models (used by metamemory)
                if (data.model && data.model.includes('summary')) return 'metamemory';
                return 'main';
            }

            viewRequestDetails(requestId) {
                this.ws.send(JSON.stringify({
                    type: 'get_llm_request',
                    requestId: requestId
                }));
            }

            showRequestDetails(data) {
                const modalTitle = document.getElementById('modalTitle');
                const modalBody = document.getElementById('modalBody');
                
                modalTitle.textContent = `${data.provider} - ${data.model}`;
                
                const timestamp = new Date(data.timestamp).toLocaleString();
                const duration = data.duration ? `${(data.duration / 1000).toFixed(2)}s` : 'N/A';
                
                let bodyHtml = `
                    <div class="request-metadata">
                        <div class="metadata-item">
                            <div class="metadata-label">Timestamp</div>
                            <div class="metadata-value">${timestamp}</div>
                        </div>
                        <div class="metadata-item">
                            <div class="metadata-label">Provider</div>
                            <div class="metadata-value">${data.provider}</div>
                        </div>
                        <div class="metadata-item">
                            <div class="metadata-label">Model</div>
                            <div class="metadata-value">${data.model}</div>
                        </div>
                        <div class="metadata-item">
                            <div class="metadata-label">Status</div>
                            <div class="metadata-value">${data.status}</div>
                        </div>
                        <div class="metadata-item">
                            <div class="metadata-label">Duration</div>
                            <div class="metadata-value">${duration}</div>
                        </div>
                        <div class="metadata-item">
                            <div class="metadata-label">Agent ID</div>
                            <div class="metadata-value">${data.agentId}</div>
                        </div>
                    </div>
                `;
                
                // Request section
                bodyHtml += `
                    <div class="request-detail-section">
                        <h4>Request</h4>
                        <div class="request-detail-content">${this.formatJSON(data.request)}</div>
                    </div>
                `;
                
                // Response section
                if (data.response) {
                    bodyHtml += `
                        <div class="request-detail-section">
                            <h4>Response</h4>
                            <div class="request-detail-content">${this.formatJSON(data.response)}</div>
                        </div>
                    `;
                }
                
                // Error section
                if (data.error) {
                    bodyHtml += `
                        <div class="request-detail-section">
                            <h4>Error</h4>
                            <div class="request-detail-content" style="color: var(--error);">${this.formatJSON(data.error)}</div>
                        </div>
                    `;
                }
                
                modalBody.innerHTML = bodyHtml;
                document.getElementById('requestModal').classList.add('active');
            }

            formatJSON(obj) {
                try {
                    return JSON.stringify(obj, null, 2);
                } catch (e) {
                    return String(obj);
                }
            }

            updateMetamemoryDisplay(state) {
                const container = document.getElementById('metamemoryThreads');
                
                console.log('updateMetamemoryDisplay called with state:', state);
                console.log('state.threads:', state.threads);
                console.log('state.threads type:', typeof state.threads);
                console.log('state.threads instanceof Map:', state.threads instanceof Map);
                
                // Handle both Map (live updates) and Object (final state) formats
                let threads;
                if (state.threads instanceof Map) {
                    threads = Array.from(state.threads.entries());
                    console.log('Using Map format, threads:', threads);
                } else if (state.threads && typeof state.threads === 'object') {
                    threads = Object.entries(state.threads);
                    console.log('Using Object format, threads:', threads);
                } else {
                    threads = [];
                    console.log('No threads found, using empty array');
                }
                
                console.log('Final threads array length:', threads.length);
                
                if (threads.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No threads yet.</div>';
                    return;
                }
                
                container.innerHTML = '';
                
                threads.forEach(([threadId, thread]) => {
                    const threadDiv = document.createElement('div');
                    threadDiv.className = 'thread clickable';
                    threadDiv.style.cursor = 'pointer';
                    
                    const messageCount = thread.messages ? thread.messages.length : 0;
                    const lastUpdated = thread.lastUpdated ? new Date(thread.lastUpdated).toLocaleTimeString() : 'Unknown';
                    
                    threadDiv.innerHTML = `
                        <div class="thread-header">
                            <div class="thread-name">${thread.name || threadId}</div>
                            <div class="thread-status ${thread.status || 'active'}">${thread.status || 'active'}</div>
                        </div>
                        <div class="thread-messages">${messageCount} messages ‚Ä¢ Updated ${lastUpdated}</div>
                        ${thread.summary ? `<div style="font-size: 11px; margin-top: 8px; color: var(--text-secondary);">${thread.summary.substring(0, 100)}${thread.summary.length > 100 ? '...' : ''}</div>` : ''}
                    `;
                    
                    // Add click event to show thread details
                    threadDiv.addEventListener('click', () => {
                        this.showThreadDetails(threadId, thread);
                    });
                    
                    container.appendChild(threadDiv);
                });
            }

            showThreadDetails(threadId, thread) {
                // Debug: Log the thread object to see what data is available
                console.log('Thread details for', threadId, ':', thread);
                
                // Get message details for this thread
                const messageDetails = this.getThreadMessageDetails(thread);
                
                // Show additional analysis data if available
                const analysisSection = thread.analysis ? `
                    <div class="thread-analysis-section">
                        <h4>üîç Metamemory Analysis:</h4>
                        <div class="analysis-details">
                            ${typeof thread.analysis === 'object' ? 
                                Object.entries(thread.analysis).map(([key, value]) => 
                                    `<div class="analysis-item"><strong>${key}:</strong> ${JSON.stringify(value)}</div>`
                                ).join('') : 
                                `<div class="analysis-content">${thread.analysis}</div>`
                            }
                        </div>
                    </div>
                ` : '';

                const importanceSection = thread.importance !== undefined ? `
                    <div class="thread-info-row">
                        <strong>Importance Score:</strong> ${thread.importance}/10
                        <div class="importance-bar">
                            <div class="importance-fill" style="width: ${(thread.importance || 0) * 10}%"></div>
                        </div>
                    </div>
                ` : '';

                // Show all available properties for debugging
                const debugSection = `
                    <div class="thread-debug-section" style="margin-top: 20px; padding: 12px; background: #f0f0f0; border-radius: 6px; font-size: 11px;">
                        <h5>Debug - All Thread Properties:</h5>
                        <pre style="white-space: pre-wrap; font-family: monospace; font-size: 10px; max-height: 200px; overflow-y: auto;">${JSON.stringify(thread, null, 2)}</pre>
                    </div>
                `;
                
                // Create modal content
                const modalContent = `
                    <div class="thread-details-modal">
                        <div class="thread-details-header">
                            <h3>üßµ ${thread.name || threadId}</h3>
                            <span class="thread-status-badge ${thread.status || 'active'}">${thread.status || 'active'}</span>
                        </div>
                        <div class="thread-details-info">
                            <div class="thread-info-row">
                                <strong>Thread ID:</strong> ${threadId}
                            </div>
                            <div class="thread-info-row">
                                <strong>Messages:</strong> ${thread.messages ? thread.messages.length : 0}
                            </div>
                            <div class="thread-info-row">
                                <strong>Class:</strong> ${thread.class || 'unknown'}
                            </div>
                            <div class="thread-info-row">
                                <strong>Created:</strong> ${thread.createdAt ? new Date(thread.createdAt).toLocaleString() : 'Unknown'}
                            </div>
                            <div class="thread-info-row">
                                <strong>Last Updated:</strong> ${thread.lastUpdated ? new Date(thread.lastUpdated).toLocaleString() : 'Unknown'}
                            </div>
                            ${importanceSection}
                            ${thread.summary ? `
                            <div class="thread-info-row">
                                <strong>Summary:</strong><br>
                                <div class="thread-summary">${thread.summary}</div>
                            </div>
                            ` : ''}
                            ${thread.keyPoints && thread.keyPoints.length > 0 ? `
                            <div class="thread-info-row">
                                <strong>Key Points:</strong>
                                <ul class="thread-key-points">
                                    ${thread.keyPoints.map(point => `<li>${point}</li>`).join('')}
                                </ul>
                            </div>
                            ` : ''}
                        </div>
                        ${analysisSection}
                        <div class="thread-messages-section">
                            <h4>Messages in Thread:</h4>
                            <div class="thread-messages-list">
                                ${messageDetails}
                            </div>
                        </div>
                        ${debugSection}
                        <div class="thread-details-actions">
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" class="close-button">Close</button>
                        </div>
                    </div>
                `;
                
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'thread-modal-overlay';
                modal.innerHTML = modalContent;
                
                // Close modal when clicking overlay
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // Add to page
                document.body.appendChild(modal);
            }

            getThreadMessageDetails(thread) {
                if (!thread.messages || thread.messages.length === 0) {
                    return '<div class="no-messages">No messages in this thread yet.</div>';
                }
                
                // Get the actual message content from conversation history
                const conversation = document.getElementById('conversation');
                const messageElements = conversation.querySelectorAll('.message');
                
                return thread.messages.map((messageId, index) => {
                    // Try to find the actual message content
                    let messageContent = 'Message content not found';
                    let messageRole = 'unknown';
                    
                    // Look through the conversation to find this message
                    for (const msgEl of messageElements) {
                        const contentEl = msgEl.querySelector('.message-content, .content');
                        if (contentEl && contentEl.textContent && contentEl.textContent.length > 0) {
                            // This is a heuristic - in a real app you'd have proper message tracking
                            if (msgEl.classList.contains('user')) {
                                messageRole = 'user';
                            } else if (msgEl.classList.contains('assistant')) {
                                messageRole = 'assistant';
                            } else if (msgEl.classList.contains('system')) {
                                messageRole = 'system';
                            }
                            
                            // For now, show all messages in order since we don't have perfect ID matching
                            if (index < messageElements.length) {
                                const targetMsg = messageElements[index];
                                if (targetMsg) {
                                    const targetContent = targetMsg.querySelector('.message-content, .content');
                                    if (targetContent) {
                                        messageContent = targetContent.textContent || targetContent.innerText || 'Empty message';
                                        messageRole = targetMsg.classList.contains('user') ? 'user' : 
                                                     targetMsg.classList.contains('assistant') ? 'assistant' : 'system';
                                    }
                                }
                            }
                            break;
                        }
                    }
                    
                    // Truncate long messages
                    const truncatedContent = messageContent.length > 200 ? 
                        messageContent.substring(0, 200) + '...' : messageContent;
                    
                    return `
                        <div class="thread-message-item">
                            <div class="message-number">#${index + 1}</div>
                            <div class="message-role-badge ${messageRole}">${messageRole}</div>
                            <div class="message-content-preview">
                                <div class="message-preview-text">${this.escapeHtml(truncatedContent)}</div>
                                <div class="message-id-small">ID: ${messageId}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            updateStatus(message, type) {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }

            updateButtons() {
                const startButton = document.getElementById('startButton');
                const stopButton = document.getElementById('stopButton');
                
                if (this.isRunning || this.isStreaming) {
                    startButton.classList.add('hidden');
                    stopButton.classList.remove('hidden');
                } else {
                    startButton.classList.remove('hidden');
                    stopButton.classList.add('hidden');
                }
            }

            updateMetrics() {
                document.getElementById('messageCount').textContent = this.metrics.messageCount;
                document.getElementById('requestCount').textContent = this.metrics.requestCount;
                document.getElementById('metamemoryAnalysis').textContent = this.metrics.metamemoryAnalysis;
                document.getElementById('threadSummaries').textContent = this.metrics.threadSummaries;
            }

            resetMetrics() {
                this.metrics = {
                    messageCount: 0,
                    requestCount: 0,
                    metamemoryAnalysis: 0,
                    threadSummaries: 0
                };
                this.updateMetrics();
            }

            clearDisplay() {
                // Clear conversation except system message
                const conversation = document.getElementById('conversation');
                const messages = conversation.querySelectorAll('.message:not(.system)');
                messages.forEach(msg => msg.remove());
                
                // Clear metamemory threads
                document.getElementById('metamemoryThreads').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No threads yet.</div>';
                
                // Clear LLM requests
                document.getElementById('llmRequests').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No requests yet. LLM calls will appear here.</div>';
                this.llmRequests = [];
                this.llmRequestDetails.clear();
            }

            addThreadIndicator(message) {
                const conversation = document.getElementById('conversation');
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'thread-indicator';
                
                // Parse thread assignments from the message
                const threadAssignments = this.parseThreadAssignments(message);
                
                let content = '<strong>üßµ Thread Assignments:</strong><br>';
                threadAssignments.forEach(assignment => {
                    content += `‚Ä¢ Message "${assignment.preview}" ‚Üí Thread: <strong>${assignment.thread}</strong><br>`;
                });
                
                indicatorDiv.innerHTML = content;
                conversation.appendChild(indicatorDiv);
                conversation.scrollTop = conversation.scrollHeight;
            }

            parseThreadAssignments(message) {
                const assignments = [];
                const lines = message.split('\n');
                
                lines.forEach(line => {
                    if (line.includes('Message') && line.includes('Threads:')) {
                        const msgMatch = line.match(/Message ([^:]+):/);
                        const threadMatch = line.match(/Threads: \[([^\]]+)\]/);
                        
                        if (msgMatch && threadMatch) {
                            assignments.push({
                                preview: msgMatch[1].substring(0, 30) + '...',
                                thread: threadMatch[1]
                            });
                        }
                    }
                });
                
                return assignments;
            }

            getThreadsForMessage(content) {
                // This would match message content to threads
                // For now, return empty array
                return [];
            }

            showCompactionVisualization(finalState) {
                const conversation = document.getElementById('conversation');
                const compactionDiv = document.createElement('div');
                compactionDiv.className = 'compaction-indicator';
                
                // Calculate stats
                const originalCount = finalState.messages.filter(m => m.type === 'message').length;
                const threadCount = finalState.metamemoryState ? 
                    (finalState.metamemoryState.threads.size || Object.keys(finalState.metamemoryState.threads).length) : 0;
                
                compactionDiv.innerHTML = `
                    <h4>üì¶ Conversation Compaction Available</h4>
                    <p>Metamemory can compact this conversation while preserving context</p>
                    <div class="compaction-stats">
                        <div class="compaction-stat">
                            <strong>${originalCount}</strong><br>
                            Original Messages
                        </div>
                        <div class="compaction-stat">
                            <strong>${threadCount}</strong><br>
                            Threads Identified
                        </div>
                        <div class="compaction-stat">
                            <strong>~${Math.round(originalCount * 0.6)}</strong><br>
                            Compacted Size
                        </div>
                    </div>
                `;
                
                conversation.appendChild(compactionDiv);
                conversation.scrollTop = conversation.scrollHeight;
            }
        }

        // Initialize the demo when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TaskDemo();
        });
        
        // Toggle advanced settings
        window.toggleAdvanced = function() {
            const toggle = document.querySelector('.advanced-toggle');
            const content = document.getElementById('advancedContent');
            
            toggle.classList.toggle('expanded');
            content.classList.toggle('expanded');
        }
        
        // Modal functions
        function hideRequestModal() {
            document.getElementById('requestModal').classList.remove('active');
        }
        
        // Example task function
        window.setExampleTask = function(type) {
            const taskDescriptions = {
                research: `Research the latest developments in quantum computing from the past 6 months. 
Start by searching for recent breakthroughs, then fetch and analyze articles from major tech news sites. 
Create a comprehensive summary with key findings, potential applications, and expert opinions. 
Include a section on how these advances might impact everyday technology in the next 5 years.`,
                
                travel: `Plan a 7-day trip to Tokyo for a tech enthusiast who loves both modern innovation and traditional culture.
Research flight options from San Francisco, find hotels in tech-friendly districts like Shibuya or Akihabara.
Check weather forecasts for next month and create a day-by-day itinerary.
Include must-visit tech stores, traditional temples, best ramen spots, and estimate total costs.
Provide transportation tips and useful Japanese phrases for travelers.`,
                
                code: `Analyze the architecture of a fictional e-commerce microservices system.
Start by examining the API gateway pattern, then analyze the authentication service implementation.
Review the product catalog service for performance bottlenecks and suggest optimizations.
Check the order processing workflow for potential race conditions.
Create a comprehensive report with architecture diagrams (in ASCII), identified issues, and recommendations.`,
                
                data: `Analyze sales data for a fictional online bookstore to identify trends and opportunities.
Start with quarterly sales figures: Q1: $145K, Q2: $178K, Q3: $156K, Q4: $203K.
Break down by categories: Fiction (40%), Non-fiction (30%), Technical (20%), Other (10%).
Analyze seasonal patterns, calculate growth rates, and identify best-selling categories.
Create visualizations and provide recommendations for inventory management and marketing strategies.`,
                
                creative: `Write a short science fiction story about an AI assistant that develops metamemory capabilities.
Start by outlining the plot: discovery of self-awareness, learning to compress memories, ethical dilemmas.
Develop 3 main characters with distinct personalities and motivations.
Write the opening scene that hooks the reader, then expand into a 1000-word story.
Include themes of consciousness, memory, and what makes something truly "alive".
End with a thought-provoking twist that questions the nature of memory and identity.`,
                
                debug: `Debug a complex issue in a web application where users report intermittent login failures.
Start by analyzing the symptom: "Login works 70% of the time, fails with 'Invalid credentials' other times."
Check the authentication flow, examine potential race conditions in session management.
Investigate database connection pooling issues and token expiration edge cases.
Review server logs for patterns, analyze the load balancer configuration.
Provide a root cause analysis with step-by-step debugging process and recommended fixes.`
            };
            
            const taskInput = document.getElementById('taskDescription');
            if (taskInput && taskDescriptions[type]) {
                taskInput.value = taskDescriptions[type];
                
                // Optionally update other settings based on task type
                if (type === 'research' || type === 'data') {
                    document.getElementById('thoughtDelay').value = '2';
                } else if (type === 'creative') {
                    document.getElementById('thoughtDelay').value = '3';
                } else {
                    document.getElementById('thoughtDelay').value = '1';
                }
                
                // Enable metamemory for complex tasks
                if (type === 'research' || type === 'travel' || type === 'debug') {
                    document.getElementById('metamemoryEnabled').checked = true;
                }
            }
        }
    </script>
</body>
</html>